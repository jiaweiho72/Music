"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useAnimatedValue;

var _react = require("react");

var _reactNativeReanimated = require("react-native-reanimated");

var _useCircleValues = _interopRequireDefault(require("./useCircleValues"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function useAnimatedValue(_ref) {
  let {
    initialValue = 0,
    radius = 60,
    maxValue = 100,
    clockwise,
    delay = 0,
    value,
    duration,
    onAnimationComplete = () => null,
    activeStrokeWidth = 10,
    inActiveStrokeWidth = 10,
    progressFormatter = v => {
      'worklet';

      return Math.round(v);
    }
  } = _ref;
  const animatedValue = (0, _reactNativeReanimated.useSharedValue)(initialValue);
  const {
    circleCircumference
  } = (0, _useCircleValues.default)({
    radius,
    activeStrokeWidth,
    inActiveStrokeWidth
  });
  const animatedCircleProps = (0, _reactNativeReanimated.useAnimatedProps)(() => {
    let biggestValue = Math.max(initialValue, maxValue);
    biggestValue = biggestValue <= 0 ? 1 : biggestValue;
    const maxPercentage = clockwise ? 100 * animatedValue.value / biggestValue : 100 * -animatedValue.value / biggestValue;
    return {
      strokeDashoffset: circleCircumference - circleCircumference * maxPercentage / 100
    };
  });
  (0, _react.useEffect)(() => {
    animatedValue.value = (0, _reactNativeReanimated.withDelay)(delay, (0, _reactNativeReanimated.withTiming)(value, {
      duration,
      easing: _reactNativeReanimated.Easing.linear
    }, isFinished => {
      if (isFinished) {
        var _runOnJS;

        (_runOnJS = (0, _reactNativeReanimated.runOnJS)(onAnimationComplete)) === null || _runOnJS === void 0 ? void 0 : _runOnJS();
      }
    }));
  }, [value]);
  const progressValue = (0, _reactNativeReanimated.useDerivedValue)(() => {
    return `${progressFormatter(animatedValue.value)}`;
  });
  const animatedTextProps = (0, _reactNativeReanimated.useAnimatedProps)(() => {
    return {
      text: progressValue.value
    };
  });
  return {
    animatedCircleProps,
    animatedTextProps,
    progressValue
  };
}
//# sourceMappingURL=useAnimatedValue.js.map